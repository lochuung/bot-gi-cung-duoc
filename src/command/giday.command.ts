import { ChannelMessage } from 'mezon-sdk';
import { Command } from '@app/decorators/command.decorator';
import { CommandMessage } from '@app/command/common/command.abstract';
import { GiDayService, GiDayRandomResult } from '@app/services/giday.service';
import { GIDAY_MESSAGES } from '@app/command/constants/giday.messages';
import { formatMessage, joinMessages, createNumberedList } from '@app/command/utils/message-formatter.utils';

@Command('giday', {
    description: 'T·∫°o danh s√°ch l·ª±a ch·ªçn v√† random m·ªôt trong s·ªë ƒë√≥',
    usage: `!giday <option1>, <option2>, <option3> - Random tr·ª±c ti·∫øp
!giday add <option> - Th√™m l·ª±a ch·ªçn v√†o danh s√°ch
!giday done - Random t·ª´ danh s√°ch ƒë√£ t·∫°o
!giday list - Xem danh s√°ch hi·ªán t·∫°i
!giday clear - X√≥a h·∫øt danh s√°ch`,
    category: 'Utility',
    aliases: ['gd', 'random', 'choice'],
})
export class GiDayCommand extends CommandMessage {
    constructor(private readonly giDayService: GiDayService) {
        super();
    }

    async execute(args: string[], message: ChannelMessage) {
        const userId = message.sender_id;

        if (args.length === 0) {
            return this.showHelp(message);
        }

        const fullArgsString = args.join(' ');

        // Check if user is providing comma-separated options (direct mode)
        if (fullArgsString.includes(',')) {
            return await this.handleDirectMode(fullArgsString, message);
        }

        // Handle subcommands
        const subCommand = args[0].toLowerCase();

        switch (subCommand) {
            case 'add':
                return await this.handleAddOption(args.slice(1), userId, message);
            case 'done':
                return await this.handleDone(userId, message);
            case 'list':
                return await this.handleList(userId, message);
            case 'clear':
                return await this.handleClear(userId, message);
            case 'help':
                return this.showHelp(message);
            default:
                // Treat as adding option (backward compatibility)
                return await this.handleAddOption(args, userId, message);
        }
    }

    private async handleDirectMode(optionsString: string, message: ChannelMessage) {
        const result = await this.giDayService.handleDirectMode(optionsString);
        
        if (!result.success) {
            return this.replyMessageGenerate(
                {
                    messageContent: result.error!,
                    mk: true,
                },
                message,
            );
        }

        return this.formatRandomResult(result.result!, message);
    }

    private async handleAddOption(optionArgs: string[], userId: string, message: ChannelMessage) {
        if (optionArgs.length === 0) {
            return this.replyMessageGenerate(
                {
                    messageContent: `‚ùå Vui l√≤ng cung c·∫•p n·ªôi dung l·ª±a ch·ªçn!\n${GIDAY_MESSAGES.INFO.TIPS.ADD_MORE}`,
                    mk: true,
                },
                message,
            );
        }

        const option = optionArgs.join(' ').trim();
        const result = await this.giDayService.addUserOption(userId, option);
        
        if (!result.success) {
            return this.replyMessageGenerate(
                {
                    messageContent: result.error!,
                    mk: true,
                },
                message,
            );
        }

        const config = this.giDayService.getConfig();
        const lines: string[] = [];
        lines.push('‚úÖ **ƒê√É TH√äM L·ª∞A CH·ªåN**');
        lines.push('');
        lines.push(`‚ûï **M·ªõi th√™m:** ${option}`);
        lines.push(formatMessage(GIDAY_MESSAGES.INFO.OPTIONS_COUNT, { 
            current: result.newTotal!.toString(),
            max: config.maxOptions.toString()
        }));
        lines.push('');
        lines.push('üí° **Ti·∫øp theo:**');
        lines.push(`   ‚Ä¢ ${GIDAY_MESSAGES.INFO.TIPS.ADD_MORE.replace('üí° ', '')}`);
        lines.push(`   ‚Ä¢ ${GIDAY_MESSAGES.INFO.TIPS.RANDOM_NOW.replace('üé≤ ', '')}`);
        lines.push(`   ‚Ä¢ ${GIDAY_MESSAGES.INFO.TIPS.VIEW_LIST.replace('üìã ', '')}`);

        return this.replyMessageGenerate(
            {
                messageContent: lines.join('\n'),
                mk: true,
            },
            message,
        );
    }

    private async handleDone(userId: string, message: ChannelMessage) {
        const result = await this.giDayService.randomizeAndClearUserOptions(userId);
        
        if (!result.success) {
            return this.replyMessageGenerate(
                {
                    messageContent: result.error!,
                    mk: true,
                },
                message,
            );
        }

        const lines: string[] = [];
        lines.push('üé≤ **K·∫æT QU·∫¢ RANDOM**');
        lines.push('');
        lines.push(`üéØ **L·ª±a ch·ªçn: ${result.result!.chosenOption}**`);
        lines.push('');
        lines.push('üìã **C√°c l·ª±a ch·ªçn ban ƒë·∫ßu:**');
        result.result!.allOptions.forEach((option, index) => {
            const prefix = index === result.result!.chosenIndex ? '‚û°Ô∏è' : '   ‚Ä¢';
            lines.push(`${prefix} ${option}`);
        });
        lines.push('');
        lines.push('üßπ *Danh s√°ch ƒë√£ ƒë∆∞·ª£c x√≥a sau khi random*');
        
        return this.replyMessageGenerate(
            {
                messageContent: lines.join('\n'),
                mk: true,
            },
            message,
        );
    }

    private async handleList(userId: string, message: ChannelMessage) {
        const listResult = await this.giDayService.getUserOptionsList(userId);

        if (listResult.totalOptions === 0) {
            return this.replyMessageGenerate(
                {
                    messageContent: joinMessages(
                        GIDAY_MESSAGES.INFO.OPTIONS_LIST_EMPTY,
                        '',
                        GIDAY_MESSAGES.INFO.TIPS.ADD_MORE
                    ),
                    mk: true,
                },
                message,
            );
        }

        const lines: string[] = [];
        lines.push(GIDAY_MESSAGES.INFO.OPTIONS_LIST_HEADER);
        lines.push('');
        listResult.options.forEach((option, index) => {
            lines.push(`   ${index + 1}. ${option}`);
        });
        lines.push('');
        lines.push(formatMessage(GIDAY_MESSAGES.INFO.OPTIONS_COUNT, { 
            current: listResult.totalOptions.toString(),
            max: listResult.maxOptions.toString()
        }));
        lines.push('');
        lines.push('üí° **Thao t√°c:**');
        lines.push(`   ‚Ä¢ ${GIDAY_MESSAGES.INFO.TIPS.ADD_MORE.replace('üí° ', '')}`);
        lines.push(`   ‚Ä¢ ${GIDAY_MESSAGES.INFO.TIPS.RANDOM_NOW.replace('üé≤ ', '')}`);
        lines.push(`   ‚Ä¢ ${GIDAY_MESSAGES.INFO.TIPS.CLEAR_ALL.replace('üßπ ', '')}`);

        return this.replyMessageGenerate(
            {
                messageContent: lines.join('\n'),
                mk: true,
            },
            message,
        );
    }

    private async handleClear(userId: string, message: ChannelMessage) {
        const result = await this.giDayService.clearUserOptions(userId);
        
        if (!result.success) {
            return this.replyMessageGenerate(
                {
                    messageContent: result.error!,
                    mk: true,
                },
                message,
            );
        }
        
        if (result.clearedCount === 0) {
            return this.replyMessageGenerate(
                {
                    messageContent: GIDAY_MESSAGES.SUCCESS.NO_OPTIONS_TO_CLEAR,
                    mk: true,
                },
                message,
            );
        }

        const successMessage = formatMessage(GIDAY_MESSAGES.SUCCESS.OPTIONS_CLEARED, { 
            count: result.clearedCount!.toString() 
        });

        return this.replyMessageGenerate(
            {
                messageContent: joinMessages(
                    successMessage,
                    '',
                    GIDAY_MESSAGES.INFO.TIPS.ADD_MORE
                ),
                mk: true,
            },
            message,
        );
    }

    private showHelp(message: ChannelMessage) {
        const config = this.giDayService.getConfig();
        const lines: string[] = [];
        lines.push('üé≤ **H∆Ø·ªöNG D·∫™N GIDAY**');
        lines.push('');
        lines.push('üìù **C√°ch 1: Random tr·ª±c ti·∫øp**');
        lines.push(`   ${GIDAY_MESSAGES.INFO.TIPS.DIRECT_MODE.replace('‚ö° ', '')}`);
        lines.push('');
        lines.push('üìù **C√°ch 2: T·∫°o danh s√°ch t·ª´ t·ª´**');
        lines.push(`   ${GIDAY_MESSAGES.INFO.TIPS.ADD_MORE.replace('üí° ', '')}`);
        lines.push('   `!giday add burger` - Th√™m ti·∫øp');
        lines.push(`   ${GIDAY_MESSAGES.INFO.TIPS.RANDOM_NOW.replace('üé≤ ', '')}`);
        lines.push('');
        lines.push('üîß **L·ªánh kh√°c:**');
        lines.push(`   ‚Ä¢ ${GIDAY_MESSAGES.INFO.TIPS.VIEW_LIST.replace('üìã ', '')}`);
        lines.push(`   ‚Ä¢ ${GIDAY_MESSAGES.INFO.TIPS.CLEAR_ALL.replace('üßπ ', '')}`);
        lines.push('');
        lines.push(`‚ö†Ô∏è **Gi·ªõi h·∫°n:** T·ªëi ƒëa ${config.maxOptions} l·ª±a ch·ªçn, t·ª± ƒë·ªông x√≥a sau 24h`);

        return this.replyMessageGenerate(
            {
                messageContent: lines.join('\n'),
                mk: true,
            },
            message,
        );
    }

    private formatRandomResult(result: GiDayRandomResult, message: ChannelMessage) {
        const lines: string[] = [];
        lines.push('üé≤ **K·∫æT QU·∫¢ RANDOM**');
        lines.push('');
        lines.push(`üéØ **L·ª±a ch·ªçn: ${result.chosenOption}**`);
        lines.push('');
        lines.push('üìã **C√°c l·ª±a ch·ªçn ban ƒë·∫ßu:**');
        result.allOptions.forEach((option, index) => {
            const prefix = index === result.chosenIndex ? '‚û°Ô∏è' : '   ‚Ä¢';
            lines.push(`${prefix} ${option}`);
        });

        return this.replyMessageGenerate(
            {
                messageContent: lines.join('\n'),
                mk: true,
            },
            message,
        );
    }
}
